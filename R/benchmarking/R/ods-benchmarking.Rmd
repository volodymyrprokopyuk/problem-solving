---
title: ODS Benchmarking
author: Vlad, Icon Solutions
date: "`r clock::date_now('')`"
abstract: ODS benchmarking report
keywords: [ODS, MongoDB, benchmarking, throughput, latency]
lang: en
css:
  - asset/style/style.css
header-includes:
  - <link rel="shortcut icon" href="asset/image/html5-favicon.png">
---

```{r doc-config, include = F}
library(ggplot2)
library(huxtable, warn.conflicts = F)

opts_chunk$set(
  echo = F, message = F, warning = F, error = F,
  dev = "svglite", fig.dim = c(11, 6)
)
```
<div class="content">

## Analysis of DB query latency distribution (raw data)

The distribution of the DB query latency (elaped time of a DB query) measured for a data
volume (number of records) in a database (MongoDB) and a number of concurrent
connections (number of threads). All latency measurements (including outliers) have been
used in the analysis.

```{r latency-distr-raw, fig.cap = "DB query lacency distribution (raw data)"}
data <- metrics # [thread_num == "10thread"]

data |>
  ggplot(aes(x = record_num, y = elapsed, color = thread_num)) +
  geom_point(position = position_dodge(0.7), size = 1) +
  geom_rug(sides = "l")
```

### Observations

- DB query latency is distributed over a **wide range** of elapsed time
- The distribution **range grows** with the increment of the database volume and the
  number of concurrent connections
- The **widest range** of the dB query latency distribution is for the 100 concurrent
  connections

## Analysis of DB query latency distribution (data without outliers)

The distribution of the DB query latency by the database volume and the number of
concurrent connections repserenting the mean, the median, the first and third quartiles,
the shape of the distribution, IQR fences and the most closer outliers. The latency
measurements without outliers have been used in the analysis.

```{r latency-distr-violin, fig.cap = "DB query latency distribution (violin plot)"}
data <- data[
  ,
  c("q1", "q3") := .(quantile(elapsed, probs = 0.25), quantile(elapsed, probs = 0.75)),
  by = .(record_num, thread_num)
][
  ,
  iqr15 := (q3 - q1) * 1.5,
  by = .(record_num, thread_num)
][
  elapsed > q1 - iqr15 & elapsed < q3 + iqr15
]

data_summary <- data[
  ,
  .(
    elapsed_min = min(elapsed),
    elapsed_q1 = quantile(elapsed, probs = 0.25),
    elapsed_median = median(elapsed) |> as.double(),
    elapsed_mean = mean(elapsed),
    elapsed_q3 = quantile(elapsed, probs = 0.75),
    elapsed_max = max(elapsed),
    throughput = .N / ((max(timeStamp) - min(timeStamp)) |> as.numeric()),
    iteration_num = .N
  ),
  by = .(record_num, thread_num)
]

t <- data_summary |> huxtable()
number_format(t)[-1, -(1:2)] <- 2
number_format(t)[, "iteration_num"] <- NA
position(t) <- "center"
bottom_border(t)[1, ] <- brdr(2, "solid", "gray")
right_border(t)[-1, 2] <- brdr(3, "double", "gray")
# bottom_border(t)[-1, ][c(F, F, T), ] <- 1
bold(t)[1, ] <- bold(t)[, 1:2] <- T
background_color(t)[1, ] <- "aquamarine"
# background_color(t)[-1, -(1:2)][c(T, F, F), ] <- "cornsilk"
background_color(t)[-1, (1:2)] <- "khaki1"
caption_pos(t) <- "bottomleft"

plot <- data |> ggplot(aes(x = record_num, y = elapsed, fill = thread_num))

plot +
  geom_violin(position = position_dodge(0.9)) +
  geom_point(
    data = data_summary,
    aes(x = record_num, y = elapsed_mean, group = thread_num),
    position = position_dodge(0.9),
    shape = 23, size = 3, fill = "cornsilk"
  ) + geom_point(
    data = data_summary,
    aes(x = record_num, y = elapsed_median, group = thread_num),
    position = position_dodge(0.9),
    shape = 21, size = 3, fill = "cornsilk"
  )
```

```{r latency-distr-boxplot, fig.cap = "DB query latency distribution (box plot)"}
plot +
  geom_boxplot(position = position_dodge(0.9)) +
  geom_point(
    data = data_summary,
    aes(x = record_num, y = elapsed_mean, group = thread_num),
    position = position_dodge(0.9),
    shape = 23, size = 3, fill = "cornsilk"
  )
```

### Observations

- The DB query **latency grows** with the increment of database volume and the increment
  of number of connections
- The DB query **latency growth is linear** with the increment of database volume
- The DB query **latency growth is exponential** with the increment of number of
  concurrent connections
- The **differentce** between the meadian (circle) and the mean (diamond) is bigger for
  higher levels of concurrency
- The DB query latency **distribution is more variable** for lower concurrency at all
  database volumes
- The DB query latency **distribution is more stable** for higher concurrency at all
  database volumes
- The DB query latency distribution is **skywed towards lower latency** with only a
  small number of DB queryies with high latency
- In all cases **the mean is above the median** which confirms that the DB query latency
  distribution is skwed towards lower latency

The density curve of DB query elapsed time with the histogram of the distiribution of
elapsed time measurements for a different database volumes and a different number of
concurrent connections

```{r latency-density, fig.cap = "DB query latency density curve"}
data |>
  ggplot(aes(x = elapsed, y = stat(density), fill = thread_num)) +
  geom_histogram(bins = 30) +
  geom_density(color = "gray50", alpha = 0.3) +
  facet_grid(thread_num ~ record_num)
```

### Observations

- The density curve is more **ragged and varied** for lower concurrency
- The density curve is more **stable** for higher concurrency
- The density curve is more **compact** for lower concurrency
- The density curve is **spread** for higher concurrency

```{r latency-distr-summary}
table <- t[, -9]
caption(table) <- "Statistical summary of DB query latency distribution"
table
```

## Summary of DB query latency

The meadian of the DB query latency for different database volumes and concurrency
levels

```{r latency-distr-barplot, fig.cap = "Summary of DB query latency (bar plot)"}
data_summary |>
  ggplot(aes(x = record_num, y = elapsed_median, fill = thread_num)) +
  geom_col(position = position_dodge(0.9), width = 0.8)
```

```{r latency-distr-line-point, fig.cap = "Summary of DB query latency (line and point plot)"}
data_summary |>
  ggplot(aes(x = record_num, y = elapsed_median, color = thread_num)) +
  geom_line(aes(group = thread_num)) +
  geom_point(size = 4)
```

### Observations

- The DB query **latency growth is linear** with the database volume increase for lower
  concurrency
- The DB query **latency growth stabilizes** with the database volume increase for
  higher concurrency
- The DB query **latency growth is exponential** with the increase of concurrency

```{r latency-distr-mean-median}
table <- t[, -c(3, 4, 7:9)]
caption(table) <- "Median and mean of DB query latency"
table
```

## Analysis of DB query throughput

The analysis of the DB query throughput for different database volumes and different
concurrency levels

```{r throughput-barpot, fig.cap = "DB query throughput (bar plot)"}
data_summary |>
  ggplot(aes(x = record_num, y = throughput, fill = thread_num)) +
  geom_col(position = position_dodge(0.9), width = 0.8)
```

```{r throughput-line-point, fig.cap = "DB query throughput (line and point plot)"}
data_summary |>
  ggplot(aes(x = record_num, y = throughput, color = thread_num)) +
  geom_line(aes(group = thread_num)) +
  geom_point(size = 4)
```

### Observations

- The DB query **throughput is constant and low** for single thread database access
- The DB query **throughput increases** with the increment of number of concurrent
  connections
- The **throughput is better** for higher concurrency and lower database volume
- The **throughput is worth** for hihger concurency and moderate database volume
- The **throuput converges** for higher concurrency and high database volume

```{r throughput-summary}
table <- t[, c(1:2, 9:10)]
caption(table) <- "DB query throughput"
table
```
</div> <!-- content -->
